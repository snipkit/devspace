package generate

import (
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strings"

	"k8s.io/klog/v2"

	"k8s.io/apimachinery/pkg/util/sets"
	gengo "k8s.io/gengo/v2"
	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/types"
)

type Gen struct {
	p       []generator.Target
	imports namer.ImportTracker

	GroupConverter func(apigroup *APIGroup)
}

func (g *Gen) Execute(outputFileName string, patterns ...string) error {
	return gengo.Execute(
		g.NameSystems(),
		g.DefaultNameSystem(),
		func(context *generator.Context) []generator.Target {
			return g.Packages(context, outputFileName)
		},
		gengo.StdBuildTag,
		patterns,
	)
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func (g *Gen) DefaultNameSystem() string {
	return "public"
}

// NameSystems returns the name system used by the generators in this package.
func (g *Gen) NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": namer.NewPublicNamer(1),
		"raw":    namer.NewRawNamer("", g.imports),
	}
}

func (g *Gen) ParsePackages(context *generator.Context) (sets.String, sets.String, string, string) {
	versionedPkgs := sets.NewString()
	unversionedPkgs := sets.NewString()
	mainPkg := ""
	apisPkg := ""
	for _, o := range context.Order {
		if IsAPIResource(o) {
			versioned := o.Name.Package
			versionedPkgs.Insert(versioned)
			unversioned := filepath.Dir(versioned)
			unversionedPkgs.Insert(unversioned)

			if apis := filepath.Dir(unversioned); apis != apisPkg && len(apisPkg) > 0 {
				panic(fmt.Errorf(
					"Found multiple apis directory paths: %v and %v", apisPkg, apis))
			} else {
				apisPkg = apis
				mainPkg = filepath.Dir(apisPkg)
			}
		}
	}
	return versionedPkgs, unversionedPkgs, apisPkg, mainPkg
}

func (g *Gen) Packages(context *generator.Context, outputFileName string) []generator.Target {
	boilerplate, err := LoadGoBoilerplate()
	if err != nil {
		klog.Warningf("failed loading boilerplate, fallback to default boilerplate: %v", err)
		boilerplate = []byte{}
	}
	g.p = []generator.Target{}
	b := NewAPIsBuilder(context)
	for _, apigroup := range b.APIs.Groups {
		if g.GroupConverter != nil {
			g.GroupConverter(apigroup)
		}

		for _, apiversion := range apigroup.Versions {
			factory := &packageFactory{apiversion.Pkg.Path, boilerplate}
			// Add generators for versioned types
			gen := CreateVersionedGenerator(apiversion, apigroup, outputFileName)
			g.p = append(g.p, factory.createPackage(context, gen))
		}

		factory := &packageFactory{apigroup.Pkg.Path, boilerplate}
		gen := CreateUnversionedGenerator(apigroup, outputFileName)
		g.p = append(g.p, factory.createPackage(context, gen))

		factory = &packageFactory{path.Join(apigroup.Pkg.Path, "install"), boilerplate}
		gen = CreateInstallGenerator(apigroup, outputFileName)
		g.p = append(g.p, factory.createPackage(context, gen))
	}

	apisFactory := &packageFactory{b.APIs.Pkg.Path, boilerplate}
	gen := CreateApisGenerator(b.APIs, outputFileName)
	g.p = append(g.p, apisFactory.createPackage(context, gen))

	return g.p
}

type packageFactory struct {
	path       string
	headerText []byte
}

// Creates a package with a generator
func (f *packageFactory) createPackage(ctx *generator.Context, gen generator.Generator) generator.Target {
	return &generator.SimpleTarget{
		PkgName:       strings.Split(filepath.Base(f.path), ".")[0],
		PkgPath:       f.path,
		PkgDir:        ctx.Universe[f.path].Dir,
		HeaderComment: f.headerText,
		GeneratorsFunc: func(c *generator.Context) (generators []generator.Generator) {
			return []generator.Generator{gen}
		},
		FilterFunc: func(c *generator.Context, t *types.Type) bool {
			return t.Name.Package == f.path
		},
	}
}

// LoadGoBoilerplate loads the boilerplate file passed to --go-header-file.
func LoadGoBoilerplate() ([]byte, error) {
	generatorName := filepath.Base(os.Args[0])
	// Strip the extension from the name to normalize output between *nix and Windows.
	generatorName = generatorName[:len(generatorName)-len(filepath.Ext(generatorName))]
	generatedByComment := strings.Replace("// Code generated by GENERATOR_NAME. DO NOT EDIT.", "GENERATOR_NAME", generatorName, -1)
	s := fmt.Sprintf("%s\n\n", generatedByComment)
	return []byte(s), nil
}
